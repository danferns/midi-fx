import{S as b,i as I,s as C,f as p,m as d,t as g,g as _,h,c as w,j as M,l as N}from"./index.9537bdcf.js";import{c as S}from"./NodeUtil.de1e0169.js";import{N as x}from"./NodeUI.ffd646b1.js";import{N as D}from"./NumericInput.39abe510.js";import{isNoteOn as j}from"./note-splitter.0991ca8f.js";function k(s){let t,i,e;function u(n){s[4](n)}let c={};return s[0].cc!==void 0&&(c.value=s[0].cc),t=new D({props:c}),w.push(()=>M(t,"value",u)),{c(){p(t.$$.fragment)},m(n,r){d(t,n,r),e=!0},p(n,r){const a={};!i&&r&1&&(i=!0,a.value=n[0].cc,N(()=>i=!1)),t.$set(a)},i(n){e||(g(t.$$.fragment,n),e=!0)},o(n){_(t.$$.fragment,n),e=!1},d(n){h(t,n)}}}function q(s){let t,i;return t=new x({props:{width:200,$$slots:{default:[k]},$$scope:{ctx:s}}}),{c(){p(t.$$.fragment)},m(e,u){d(t,e,u),i=!0},p(e,[u]){const c={};u&513&&(c.$$scope={dirty:u,ctx:e}),t.$set(c)},i(e){i||(g(t.$$.fragment,e),i=!0)},o(e){_(t.$$.fragment,e),i=!1},d(e){h(t,e)}}}const A=`
    Emits Control Change (CC) messages based on the velocity of incoming node on messages.
    Some smoothing is applied to the output to avoid sudden jumps in the CC value.
    `;let y=.2;function E(s,t,i){let{id:e}=t;const u={MIDI:(o,v,l)=>{j(o,v,l)&&(a=l)}},c={MIDI:new Set};let{state:n={cc:0}}=t;const r=S(e,c);let a=0,m=0;function f(){Math.round(m)!==a&&(m+=(a-m)/(y*50),r("MIDI",176,n.cc,m)),setTimeout(f,1e3/50)}f();function $(o){s.$$.not_equal(n.cc,o)&&(n.cc=o,i(0,n))}return s.$$set=o=>{"id"in o&&i(1,e=o.id),"state"in o&&i(0,n=o.state)},[n,e,u,c,$]}class B extends b{constructor(t){super(),I(this,t,E,q,C,{id:1,inputs:2,outputs:3,state:0})}get inputs(){return this.$$.ctx[2]}get outputs(){return this.$$.ctx[3]}}export{B as default,A as doc};
